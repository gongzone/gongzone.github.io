---
title: 'Cypress Component 테스트 (feat. Jest, Testing-Library)'
description: 'Cypress는 더 이상 E2E 테스팅만을 위한 도구가 아닙니다. 새로운 기능인 Component 테스팅에 대해 알아봅니다.'
slug: 'cypress-component-testing'
image: './assets/main.jpg'
tags: ['Testing']
date: '2022-10-15'
---

## 1. 개요

이 글은 E2E 테스팅 툴의 대표격인 **Cypress**의 새로운 기능인 **Component 테스팅**을 간략히 소개하려는 목적으로 작성되었다.
설치 방법이나 테스트 가이드라인을 설명하려는 글이 아니다. 
설치 방법의 경우에는 [공식문서](https://docs.cypress.io/guides/component-testing/writing-your-first-component-test)
을 확인하는 것이 더 정확할 것이며, 테스트 가이드라인의 경우에는 나중에 시리즈로 묶어 글을 작성할 계획이다.

해당 글을 작성하게 된 주요 동기는 개인적인 만족감 때문이다. 
평소 React 테스트 코드를 작성할 때, 
**Jest + Testing-Library** 조합을 사용했지만 **Cypress Component 테스팅**이 그 역할을 더 훌륭히 수행할 수 있다는 생각이 들었다. 
아래 글에서는 Cypress Component 테스팅이 무엇인지 또 어떤 점이 강점인지에 대해서 글을 풀어나가 보겠다.

## 2. Cypress Component 테스팅이 무엇인가?

**Cypress**는 E2E 테스트를 위한 도구로 유명세를 얻었다. 
**E2E 테스트**란 여러 모듈로 분화된 애플리케이션이 전체적으로 기대하는 바에 따라 동작하는지 검증하는 
기술 혹은 과정이라 볼 수 있다. 말 그대로 End-to-End 테스트, 혹은 통합 테스트이다.
frontend, backend 코드들이 어떻게 동작하고 사용되는지 보다는,
최종 사용자(end-user)가 우리 제품을 사용하게 될 환경을 조성하고 시뮬레이션하여
기대하는 바를 서술하고 검증하는 것이 E2E 테스트의 핵심이다.

반면에 **Cypress**에서 말하는 **Component 테스팅**은 우리가 컴포넌트라고 부르는 작은 단위를 테스팅하는 것이다.
현대 대부분의 프론트엔드 프레임워크는 컴포넌트라는 논리적 단위로 애플리케이션을 잘게 쪼개서 구성하도록 하는데,
이 각각의 모듈을 검증하는 것이 Component 테스팅이다.

허나 명심해야 할 것은 모든 컴포넌트 테스트가 통과하더라도 그 자체로 나의 애플리케이션이 무결하다라는 것을
보장할 순 없다는 점이다. 예를들어 어떤 컴포넌트에서 API 호출을 하는데, 해당 컴포넌트의 독립적
공간안에서는 그 API의 존재에 대해서 알 수가 없기 때문에 mocking이 필요하다.
mocking은 mocking일 뿐, 실제 API 호출로 이루어진 결과 값을 반환받는 것이 아니기 때문에 무결성을 보장할 수 없다는
얘기이다. 따라서 E2E, Component 테스팅을 잘 조합하여 애플리케이션을 구축하는 것이 중요하다고 볼 수 있다.

## 3. Cypress Component 테스팅의 강점 - 브라우저 환경에서의 테스트

React 테스트 코드 작성의 경우 Jest와 Testing-Library 조합을 대부분 많이 사용하는 추세이다. 
위 조합으로 다음과 같은 테스트 코드를 작성한다고 가정해보자.

- 모바일 화면에서는 햄버거 아이콘 버튼이 헤더에 나타나는 것을 검증해주세요.
- 햄버거 아이콘 버튼을 클릭했을 시 사이드 메뉴가 나타나는 것을 검증해주세요.

굉장히 쉬운 요구사항이지 않는가? 그러나 실상은 그렇지 않다.

첫 번째, 반응형을 검증하는 요구사항을 먼저 살펴보자. Testing-Library의 API들을 살펴봐도 브라우저 window 사이즈를
조절하는 메소드는 보이지 않는다. `window.matchMedia`를 수동적으로 설정하여 우회하는 해결책을 
찾아 볼 수 있지만, 개인적인 경험으로는 기대만큼 잘 작동하지 않았다.

두 번째, 햄버거 아이콘을 클릭하면 사이드 메뉴의 스타일 속성이 `display: none` 에서 `display: block`으로 바뀌어
화면에 나타나는 경우라고 생각해보자. 인라인 스타일인 경우는 문제 없이 다음과 같은 테스트 코드로 검증이 될 것이다. 


```js
test('when hamburger icon clicked, side menu should be opened', async () => {
  const user = userEvent.setup();
  render(<Header />);

  const hamburgerIconBtn = screen.getByRole('button', {
    name: `/hamburger/`,
  });

  const sideMenu = screen.queryByRole('navigation', {
    name: `/sidebar-menu/i`
  })

  expect(sideMenu).not.toBeVisible()

  await user.click(hamburgerIconBtn)

  expect(sideMenu).toBeVisible()
});
```

그러나 외부 CSS 라이브러리 or 프레임워크 같이 변환과정이 수반되는 경우는 
특정한 설정 없이는 테스트가 통과하지 않을 것이다. 실제 브라우저 화면에서는 사이드 메뉴가 보일지라도 말이다.

이 모든 문제는 Jest + Testing-Library이 **실제 브라우저 환경에서 수행되는 테스트가 아니라는 점**이다.
Node.js 환경에서 동작하는 테스트는 **JSDOM**을 이용하여 브라우저 환경을 모방한다.
이 역시 모방은 모방일 뿐, 실제 UI 테스트에 있어서 무결성을 보장하지 않는다.

이에 반해 **Cypress Component 테스팅**의 가장 큰 강점은 **실제 브라우저를 기반으로 테스트 검증**한다는 것이다. 
따라서 반응형 테스트가 가능하고 CSS나 자질구레한 모방 환경에서의 문제들로 골치를 썩힐 필요가 없다.
이 밖에도 크로스 브라우징 테스트, 실제 화면을 보면서 테스트 작동을 확인할 수 있다는 점, 직접적인 컴포넌트 인터렉션
이 가능하다는 점 등을 장점으로 뽑을 수 있다.

그렇다면 테스트 피드백 속도에 대해서는 어떠한가?  
**Cypress Component 테스팅**은 기존 E2E 테스트와는 다르게 
완전한 웹사이트를 렌더링 하는 것이 아니라 개발 서버를 이용해 특정 컴포넌트만을 빌드한다. 따라서 더 적은 의존성,
infrastructure가 요구되어진다. Jest + Testing-Library 조합보다는 느릴 수 있지만, 개인적인 경험으로는 상당히 
빠른 피드백을 제공해주었다.

## 4. 마무리

**Cypress Component 테스팅**은 현재 작성일 기준 아직까진 beta 버전이다. 그에 따라 공식적으로 지원하지 않는 프레임워크들도 존재한다.
그럼에도 별다른 문제 없이 많은 부분 안정화되었다고 느껴졌다. 앞으로의 프론트엔드 테스팅 환경이 어떻게 변화할지 기대하며 이만 글을 마친다.


